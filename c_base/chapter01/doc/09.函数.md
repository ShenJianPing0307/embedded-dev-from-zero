## 一、函数概述

- 函数的基本用法
- 函数的参数传递
- 数组在函数间传参
- 指针函数
- 递归函数和函数指针

## 二、函数的基本用法

函数是一个完成特定功能的代码模块，其程序代码独立，通常要求有返回值，也可以是空值。

一般形式如下:

><数据类型>  <函数名称>( <形式参数说明> ) {
>
>​            语句序列；
>
>​            return[(<表达式>)];
>
>} 

- <数据类型>是整个函数的返回值类型。return[(<表达式>)]语句中表达式的值，要和函数的<数据类型>保持一致。如无返回值应该写为void型
- <形式参数说明>是逗号”，”分隔的多个变量的说明形式
- 大括弧对 {<语句序列> }，称为函数体；<语句序列>是大于等于零个语句构成的

函数的说明就是指函数原型 ，其中，<形式参数说明>可以缺省说明的变量名称，但类型不能缺省，例如：

```c
double  Power(double x, int n) ;
double  Power(double, int);
```

函数的使用也叫函数的调用,形式如下：

> 函数名称（〈实际参数〉）

- 实参就是在使用函数时，调用函数传递给被调用函数的数据。需要确切的数据

- 函数调用可以作为一个运算量出现在表达式中，也可以单独形成一个语句。对于无返回值的函数来讲，只能形成一个函数调用语句。

```c
#include <stdio.h>

double cal(double, int)；

double cal(double x, int n) {

    double res = 1;
    for (int i = 1; i <= n;  i++) {
        res *= res * x;
    }
    return res;

}


int main(int argc, char *argv[]) {

    double x = 2, res;
    int n =2;
    res = cal(x, n);

    printf("res=%lf\n", res);

}
```

## 三、函数的参数传递

函数之间的参数传递方式：

- 全局变量

- 复制传递方式

- 地址传递方式

### （一）全局变量

全局变量就是在函数体外说明的变量，它们在程序中的每个函数里都是可见的

全局变量一经定义后就会在程序的任何地方可见。函数调用的位置不同，程序的执行结果可能会受到影响。不建议使用

```c
#include <stdio.h>

// 全局变量
double y = 2;
int m =2;

double cal()；

double cal(double x, int n) {

    double res = 1;
    for (int i = 1; i <= n;  i++) {
        res *= res * x;
    }
    return res;

}

int main(int argc, char *argv[]) {

    double res;

    res = cal(y, m);

    printf("res=%lf\n", res);

}
```

### （二）复制传递方式

![复制传递方式](../images/52.png)

```c
#include <stdio.h>

double cal(double, int);

int main(int argc, char *argv[]) {

    double x = 2, res;
    int n =2;

    printf("main &x=%p, &n=%p\n", &x, &n); // &x=0xbf81f9e8, &n=0xbf81f9e4

    res = cal(x, n);

    printf("res=%lf\n", res);

}

double cal(double x, int n) { // double x = x; int n =n;

    double res = 1;
    printf("cal &x=%p, &n=%p\n", &x, &n); // &x=0xbf81f998, &n=0xbf81f9c8
    for (int i = 1; i <= n;  i++) {
        res *= res * x;
    }
    return res;

}

```

传递的`x`、`n`参数的地址值不一样，不是同一个变量。

### （三）地址传递方式

按地址传递,实参为变量的地址，而形参为同类型的指针

被调用函数中对形参的操作，将直接改变实参的值（被调用函数对指针的目标操作，相当于对实参本身的操作）

#### 1 、编程一

编程：写一个函数，实现两个数据的交换

```c
#include <stdio.h>

void swap(int *, int *);

int main(int argc, char *argv[]) {

    int a = 1, b = 2;

    swap(&a, &b);

    printf("a=%d, b=%d\n", a, b); // a=2, b=1

}

void swap(int * a, int * b) {

    int t;

    t = *a;
    *a = *b;
    *b = t;

}
```

#### 2、编程二

编写一个函数，统计字符串中小写字母的个数，并把字符串中的小写字母转化成大写字母

```c
#include <stdio.h>

int str_func(char *);


int main(int argc, char *argv[]) {
    char s[] = "Hello";
    int n;

    n = str_func(s);
    printf("n=%d %s\n", n, s);

    return 0;
}

int str_func(char * p) { // char * p = s;
    int num = 0;

    while (*p != '\0') { // while (*p)

        if (*p <= 'z' && *p >= 'a') {
            num++;
            *p -= ' ';
        }

        p++;
    }
    return num;
}


```

## 四、数组在函数间传参

- 全局数组传递方式
- 复制传递方式 (实参为数组的指针，形参为数组名 (本质是一个指针变量) )
- 地址传递方式 (实参为数组的指针，形参为同类型的指针变量)

### （一）编程一

编写函数，计算一个一维整形数组的所有元素的和

#### 1、复制传递方式

```c
#include <stdio.h>

int array_sum(int data[], int n);

int main(int argc, char *argv[]) {

    int a[] = {10, 2, 5, 89, 36, 6};
    int sum = 0;

    sum = array_sum(a, sizeof(a)/sizeof(int));

    printf("sum=%d\n", sum);

    return 0;

}

int array_sum(int data[], int n) { // int data[] = a;error  int * data = a;

    int ret = 0;

    for(int i = 0; i < n; i++) {
        ret += data[i];
    }

    return ret;

}
```

#### 2、地址传递方式

```c
#include <stdio.h>

int array_sum(int data[], int n);

int main(int argc, char *argv[]) {

    int a[] = {10, 2, 5, 89, 36, 6};
    int sum = 0;

    sum = array_sum(a, sizeof(a)/sizeof(int));

    printf("sum=%d\n", sum);

    return 0;

}

int array_sum(int * data, int n) { // int * data = a

    int ret = 0;

    for(int i = 0; i < n; i++) {
        ret += *(data+i); // ret += data[i];
    }

    return ret;

}
```

### （二）编程二

编写函数，删除字符串中的空格

```c
#include <stdio.h>

void del_space(char * s1);

int main(int argc, char *argv[]) {

    char s[] = "s lk h n";

    del_space(s);

    puts(s);

}

void del_space(char * s1) {

    char * s2 = s1;

    while (*s1) {
        if (*s1 == ' ') {
            s1++;
        } else {
            *s2 = *s1;
            s1++;
            s2++;
        }

    }
    *s2 = '\0';

}
```





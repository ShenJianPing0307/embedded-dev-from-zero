## 一、线程概念

进程有独立的地址空间，Linux为每个进程创建`task_struct`，每个进程都参与内核调度，互不影响，但是进程在切换时系统开销大，所以很多操作系统引入了轻量级进程LWP，同一进程中的线程共享相同地址空间，Linux不区分进程、线程。

**线程特点**：

- 通常线程指的是共享相同地址空间的多个任务
- 使用多线程的好处
  - 大大提高了任务切换的效率
  - 避免了额外的TLB & cache的刷新

![线程概念及创建](../images/04.png)

**线程共享资源**：

一个进程中的多个线程共享以下资源：

- 可执行的指令
- 静态数据
- 进程中打开的文件描述符
- 当前工作目录
- 用户ID
- 用户组ID

**线程私有资源**：

每个线程私有的资源包括：

- 线程ID (TID)
- PC(程序计数器)和相关寄存器
- 堆栈
- 错误号 (errno)
- 优先级
- 执行状态和属性

## 二、线程创建

#### 1、Linux线程库

**pthread线程库中提供了如下基本操作**：

- 创建线程
- 回收线程
- 结束线程

**同步和互斥机制**：

- 信号量
- 互斥锁

#### 2、线程创建– pthread_create
```c
#include  <pthread.h>
 int  pthread_create(pthread_t *thread, const
       pthread_attr_t *attr, void *(*routine)(void *), void *arg);

```

成功返回0，失败时返回错误码

- thread 线程对象

- attr 线程属性，NULL代表默认属性

- routine 线程执行的函数

- arg 传递给routine的参数 ，参数是void * ，注意传递参数格式

**单线程创建**：

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *testThread(void *arg) {
    printf("this is thread test, pid=%d, tid=%lu\n", getpid(), pthread_self());
    printf("input arg=%d\n",(int)arg);
    pthread_exit(NULL);
    printf("after pthread exit\n");
}

int main() {

    pthread_t tid;
    int ret;
    int arg = 5;

    ret = pthread_create(&tid, NULL, testThread, (void *)arg);

    printf("this is main thread, tid=%lu\n", tid);

    sleep(10);

}
```

**多线程创建**：

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *testThread(void *arg){

    printf("this is thread test, pid=%d, tid=%lu\n", getpid(), pthread_self());
    printf("this is %d thread\n", (int)arg);
    while(1) {
        sleep(1);
    }

}

int main() {

    pthread_t tid[5];
    int ret;
    int arg = 5;
    int i;

    for(i=0; i<5;i++) {
        ret = pthread_create(&tid[i], NULL, testThread, (void *)i);
        printf("this is main thread, tid=%lu\n", tid[i]);
    }

    while(1) {

        sleep(1);

    }

}
```

#### 3、线程结束– pthread_exit
```c
#include  <pthread.h>
 void  pthread_exit(void *retval);

```

- 结束当前线程

- retval可被其他线程通过pthread_join获取

- 线程私有资源被释放

#### 4、线程查看– tid函数

```c
pthread_t  pthread_self(void)   //查看自己的TID
#include <pthread.h>
pthread_t pthread_self(void);

```

#### 5、线程回收– pthread_join

```c
#include  <pthread.h>
 int  pthread_join(pthread_t thread, void **retval);

```

对于一个默认属性的线程 A来说，线程占用的资源并不会因为执行结束而得到释放 。

- 成功返回0，失败时返回错误码

- thread 要回收的线程对象

- 调用线程阻塞直到thread结束

- *retval 接收线程thread的返回值

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *func(void *arg) {

    printf("this is child thread\n");
    sleep(25);
    pthread_exit("thread return");

}


int main() {

    pthread_t tid[100];
    void *retv;
    int i;

    for(i=0; i<100; i++) {
        pthread_create(&tid[i], NULL, func, NULL);
    }

    for(i=0; i<100; i++) {

        pthread_join(tid[1], &retv);
        printf("thread ret=%s\n", (char *)retv); //ret=thread return

    }

    while(1) {
        sleep(1);
    }

}
```

#### 6、线程分离– pthead_detach(线程回收的第二种方式)

**方式一**：

```c
int pthread_detach(pthread_t thread);    //成功：0；失败：错误号

```

指定该状态，线程主动与主控线程断开关系。线程结束后（不会产生僵尸线程）

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>


void *func() {

    pthread_detach(pthread_self());
    printf("this is child thread\n");
    sleep(25);
    pthread_exit("thread return!");

}

int main() {

    pthread_t tid[100];
    void *retv;
    int i;

    for(i=0; i<100; i++) {

        pthread_create(&tid[i], NULL, func, NULL);

    }
    while(1) {
        sleep(1);
    }

}
```

**方式二**：

**设置线程属性为分离**：

>pthread_attr_t attr;       //通过线程属性来设置游离态（分离态）
>
>pthread_attr_init(&attr);
>
>pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *func(void *arg) {
    printf("this is child thread\n");
    sleep(25);
    pthread_exit("thread return");
}

int main() {

    pthread_t tid[1000];
    void *retv;
    int i;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    for(i=0; i<1000; i++) {

        pthread_create(&tid[i], &attr, func, NULL);

    }

    while(1) {

        sleep(1);

    }


}
```

#### 7、取消一个线程

- int pthread_cancel(pthread_t thread);     杀死一个线程
- void pthread_testcancel(void);
- int pthread_setcancelstate(int state, int *oldstate);
- PTHREAD_CANCEL_ENABLE
- PTHREAD_CANCEL_DISABLE
- int pthread_setcanceltype(int type, int *oldtype);
- PTHREAD_CANCEL_DEFERRED                
- PTHREAD_CANCEL_ASYNCHRONOUS     

#### 8、线程清理

- void pthread_cleanup_push(void (*routine) (void *), void *arg)
- void pthread_cleanup_pop(int execute)

## 三、线程的同步与互斥

### （一）互斥

- 临界资源

 一次只允许一个任务(进程、线程)访问的共享资源

- 临界区

访问临界资源的代码

- 互斥机制

mutex互斥锁

任务访问临界资源前申请锁，访问完后释放锁

### （二）互斥锁

#### 1、互斥锁初始化– pthread_mutex_init
```c
#include  <pthread.h>
 int  pthread_mutex_init(pthread_mutex_t *mutex,
       const pthread_mutexattr_t *  attr);

```

- 成功时返回0，失败时返回错误码
-  mutex  指向要初始化的互斥锁对象
-  attr  互斥锁属性，NULL表示缺省属性
- man 函数出现 No manual entry for pthread_mutex_xxx解决办法  apt-get install manpages-posix-dev 

#### 2、互斥锁销毁 pthread_mutex_destroy

```c
int pthread_mutex_destroy(pthread_mutex_t *mutex)

```

#### 3、申请锁 – pthread_mutex_lock

```c
#include  <pthread.h>
 int  pthread_mutex_lock(pthread_mutex_t *mutex);
 int pthread_mutex_trylock(pthread_mutex_t *mutex)

```

- 成功时返回0，失败时返回错误码
- mutex  指向要初始化的互斥锁对象
- pthread_mutex_lock 如果无法获得锁，任务阻塞
- pthread_mutex_trylock 如果无法获得锁，返回EBUSY而不是挂起等待

#### 4、释放锁 – pthread_mutex_unlock

```c
#include  <pthread.h>
 int  pthread_mutex_unlock(pthread_mutex_t *mutex);

```

- 成功时返回0，失败时返回错误码
- mutex  指向要初始化的互斥锁对象
- 执行完临界区要及时释放锁

#### 5、读写锁

>初始化一个读写锁   pthread_rwlock_init
>
>读锁定读写锁        pthread_rwlock_rdlock
>
>非阻塞读锁定　　pthread_rwlock_tryrdlock
>
>写锁定读写锁      pthread_rwlock_wrlock
>
>非阻塞写锁定      pthread_rwlock_trywrlock
>
>解锁读写锁         pthread_rwlock_unlock
>
>释放读写锁         pthread_rwlock_destroy

### （三）信号量

#### 1、什么是死锁

![同步和互斥机制](../images/05.png)

#### 2、条件变量

```c
pthread_cond_wait(&m_cond,&m_mutex); 
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex,
           const struct timespec *restrict abstime);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);

```














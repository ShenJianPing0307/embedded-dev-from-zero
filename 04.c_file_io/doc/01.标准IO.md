## 一、文件的概念和类型

文件是一组相关数据的有序集合，包含以下类型：

- 常规文件    r  
- 目录文件    d
- 字符设备文件    c
- 块设备文件    b
- 管道文件    p
- 套接字文件    s
- 符号链接文件    l

## 二、标准IO

### （一）介绍

标准I/O由ANSI C标准定义，主流操作系统上都实现了C库，标准I/O通过缓冲机制减少系统调用，实现更高的效率。

C库函数适配了各种操作系统的差异，建立在系统调用之上。

![标准IO](../images/01.png)

### （二）流（FILE）

#### 1、介绍

标准IO用一个结构体类型来存放打开的文件的相关信息，标准I/O的所有操作都是围绕FILE来进行，FILE又被称为流(stream)，文本流/二进制流。

对于流需要注意的是在Windows和Linux操作系统中换行符的不同：

- Windows

>二进制流：   换行符      ‘\n’ 
>
>文本流：   换行符     ‘\r’ ‘\n’

- Linux

>换行符      ‘\n’ 

#### 2、流的缓冲

流的缓冲有三种类型：全缓冲、行缓冲、无缓冲

- 全缓冲

当流的缓冲区无数据或无空间时才执行实际I/O操作

- 行缓冲

当在输入和输出中遇到换行符(‘\n’)时，进行I/O操作，当流和一个终端关联时，典型的行缓冲

- 无缓冲

数据直接写入文件，流不进行缓冲

#### 3、预定义流

标准I/O预定义3个流，程序运行时自动打开，分别为：stdin、stdout、stderr

![预定义流](../images/02.png)

stdin、stdout 默认是行缓冲，stderr没有缓冲

#### 4、代码

- 代码一

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {

    int i = 0;
    printf("a"); // 没有输出任何内容
    while (1) {
    sleep(1);
    }

    return 0;

}
```

只有程序正常结束才会刷新缓存，输出内容

如果加入换行符会进行行刷新，输出内容：

```c
...
printf("a\n");
...
```

- 代码二

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {

    int i;
    for(i = 0; i < 1025; i++) {
         printf("a"); //缓冲区满了，会刷新进行内容输出
    }

    while (1) {
    sleep(1);
    }

    return 0;

}
```

缓冲区满了，会刷新缓冲区，进行内容输出，即是全缓冲的无空间情况。

### （三）文件

#### 1、文件的打开

下列函数可用于打开一个标准I/O流：

```c
FILE *fopen (const char *path, const char *mode);
```

成功时返回流指针；出错时返回NULL

- mode参数

![文件的打开](../images/03.png)

![文件的打开](../images/04.png)

- 新建文件权限

fopen() 创建的文件访问权限是0666(rw-rw-rw-)

Linux系统中umask设定会影响文件的访问权限，其规则为(0666 & ～umask)

Root用户是 022 普通用户是002

用户可以通过umask函数或者命令修改相关设定

#### 2、文件的关闭

```c
int fclose(FILE *stream)；
```

- fclose()调用成功返回0，失败返回EOF，并设置errno
- 流关闭时自动刷新缓冲中的数据并释放缓冲区
- 当一个程序正常终止时，所有打开的流都会被关闭。
- 流一旦关闭后就不能执行任何操作

#### 3、处理错误信息

```c
extern int  errno; // #include <errno.h>
void perror(const char *s); // #include <stdio.h>
char *strerror(int errno); // #include <string.h>
```

- errno 存放错误号，由系统生成

- perror先输出字符串s，再输出错误号对应的错误信息

- strerror根据错误号返回对应的错误信息

#### 4、代码

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main(int argc, char *argv[]) {

    FILE *fp;
    int fpret;

    if ((fp = fopen("1.txt", "r")) == NULL) {

        perror("fopen");
        printf("errno: %d fopen:%s\n", errno, strerror(errno));
        
        return -1;
        
    } else {
        printf("fopen success\n");
        if ((fpret = fclose(fp)) == 0) {
            printf("fclose success\n");
        } else {
            perror("fclose");
        }
    }

    return 0;

}

```

### （四）读写流

流支持不同的续写方式：

- 读写一个字符：fgetc()/fputc()一次读/写一个字符

- 读写一行：fgets()和fputs()一次读/写一行

- 读写若干个对象：fread()/fwrite() 每次读/写若干个对象，而每个对象具有相同的长度

流的输入、输出是针对缓冲区来讲的，比如：`fgetc`是字符输入，是从其它的地方对缓冲区输入

#### 1、字符的输入和输出

##### 1.1 字符输入

下列函数用来输入一个字符:

```c
 #include  <stdio.h>

 int  fgetc(FILE *stream);
 int  getc(FILE *stream);   //宏
 int  getchar(void);
```

- 成功时返回读取的字符；若到文件末尾或出错时返回EOF（-1），

- getchar()等同于fgetc(stdin)

- getc和fgetc区别是一个是宏一个是函数

**代码**：

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    int ch;
    FILE *fp;
    if ((fp = fopen("1.txt", "r")) == NULL) {
        perror("fopen");
        return -1;
    }
    while ((ch = fgetc(fp)) != EOF) {
        printf("ch=%c\n", ch);
    }
    return 0;
}
```

>知识点：
>
>  ch = fgetc(stdin);
>
>  printf(“%c\n”, ch);

##### 1.2 字符输出

下列函数用来输出一个字符:

```c
#include  <stdio.h>
int  fputc(int c, FILE *stream);
int  putc(int c, FILE *stream);
int  putchar(int c);
```

- 成功时返回写入的字符；出错时返回EOF

- putchar(c)等同于fputc(c, stdout)

```c
#include <stdio.h>

int main(int argc,  char * argv[]) {

    FILE *fp;
    int ch;

    if ((fp = fopen("1.txt", "w")) == NULL) {

        perror("fopen");
        return -1;

    }

    for (ch = 'a'; ch <= 'z'; ch++) {

        fputc(ch, fp);

    }

    return 0;

}
```

>知识点：
>
>fputc(‘a’, stdout);
>
>putchar(‘\n’);

#### 2、行输入和输出

##### 2.1 行输入

下列函数用来输入一行:

```c
#include  <stdio.h>
char  *gets(char *s);
char *fgets(char *s, int size, FILE *stream);
```

- 成功时返回s，到文件末尾或出错时返回NULL

- gets不推荐使用，容易造成缓冲区溢出

- 遇到’\n’或已输入size-1个字符时返回，总是包含’\0’

```c
#include <stdio.h>

/*
* 从文件中读出字符
*/
int main(int argc, char *argv[]) {

    FILE *fp;
    char *ret;
    char buff[100];

    if ((fp = fopen("1.txt", "a+")) == NULL) {
        perror("fopen");
        return -1;
    }

    if ((ret = fgets(buff, 5, fp)) == NULL) {
        perror("fgets");
        fclose(fp);
        return -1;
    }

    printf("buff=%s\n", buff);

    return 0;

}
```

从输入流读入：

>char buf[N];
>
>fgets(buf, N, stdin);
>
>printf(“%s”, buf);

##### 2.2 行输出

下列函数用来输出字符串:

```c
#include  <stdio.h>
int  puts(const char *s);
int fputs(const char *s,  FILE *stream);
```

- 成功时返回非负整数；出错时返回EOF

- puts将缓冲区s中的字符串输出到stdout，并追加’\n’

- fputs将缓冲区s中的字符串输出到stream,不追加  ‘\n’

```c
#include <stdio.h>

/*
* 将缓冲区内容写入到文件
*/
int main(int argc, char *argv[]) {

    FILE *fp;
    int ret;
    char buff[] = "hello world";
    if ((fp = fopen("1.txt", "a+")) == NULL) {
        perror("fopen");
        return -1;
    }

    if ((ret = fputs(buff, fp)) == -1) {
        perror("fputs");
        fclose(fp);
        return -1;
    }

    printf("fputs success\n");

    return 0;

}
```

**注意**：输出的字符串中可以包含’\n’，也可以不包含

#### 3、对象读写

下列函数用来从流中读写若干个对象:

```c
#include  <stdio.h>
size_t fread(void *ptr, size_t size, size_t n, FILE *fp);
size_t fwrite(const void *ptr, size_t size, size_t n, FILE *fp);
```

- 成功返回读写的对象个数；出错时返回EOF
- 既可以读写文本文件，也可以读写数据文件
- 效率高

##### 3.1 fwrite

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student {
    char name[16];
    int age;
    char sex[8];
};

int main(int argc, char *argv[]) {

    FILE *fp;
    size_t ret;

    struct student stu;
    struct student stu2;

    if((fp=fopen("1.bin", "w")) == NULL) {
        perror("fopen");
        return 0;
    }

    strcpy(stu.name, "zhangsan");
    stu.age = 49;
    strcpy(stu.sex, "male");

    ret = fwrite(&stu, sizeof(stu), 1, fp);
    if(ret == -1) {
        perror("fwrite");
        goto end;
    }
    printf("name=%s, age=%d, sex=%s\n", stu2.name, stu2.age, stu2.sex);

end:
    fclose(fp);

}

```

##### 3.2 fread

- 实例一

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student {
    char name[16];
    int age;
    char sex[8];
};

int main() {

    FILE *fp;
    size_t ret;

    struct student stu2;

    if((fp = fopen("1.bin", "r")) == NULL) {
        perror("fopen");
        return 0;
    }

    ret = fread(&stu2, sizeof(stu2), 1, fp);
    if(ret == -1) {
        perror("fread");
        goto end;
    }

    printf("name=%s, age=%d, sex=%s\n", stu2.name, stu2.age, stu2.sex);

end:
    fclose(fp);

}
```

- 实例二

```c
#include <stdio.h>
#include <stdlib.h>


int main(int argc, char *argv[]) {

    FILE *fp;
    char *buff;
    size_t ret;

    if((fp=fopen("1.txt", "r")) == NULL) {
        perror("fopen");
        return 0;
    }

    if((buff = (char*)malloc(100)) == NULL) {
        perror("malloc failed");
        return 0;
    }

    ret = fread(buff, 10, 1, fp);
    if(ret == -1) {
        perror("fread");
        goto end;
    }
    printf("buff=%s\n", buff);

end:
    free(buff);
    fclose(fp);

}
```

### （五）流的刷新和定位

#### 1、流的刷新

```c
#include <stdio.h>

int fflush(FILE *fp);
```

- 成功时返回0；出错时返回EOF

- 将流缓冲区中的数据写入实际的文件

- Linux下只能刷新输出缓冲区,输入缓冲区丢弃

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {

    FILE *fp;
    if((fp = fopen("1.txt", "w")) == NULL) {
        perror("fopen");
        return 0;
    }

    fwrite("abcdef", 7, 1, fp);
    fflush(fp);

    while(1) {
        sleep(1);
    }

    return 0;

}
```

#### 2、流的定位

```c
#include  <stdio.h>

long ftell(FILE *stream);
long fseek(FILE *stream, long offset,  int whence);
void rewind(FILE *stream);
```

- ftell() 成功时返回流的当前读写位置，出错时返回EOF

- fseek()定位一个流，成功时返回0，出错时返回EOF 

- whence参数：SEEK_SET/SEEK_CUR/SEEK_END

- SEEK_SET 从距文件开头 offset 位移量为新的读写位置

- SEEK_CUR：以目前的读写位置往后增加 offset 个位移量

- SEEK_END：将读写位置指向文件尾后再增加 offset 个位移量

- offset参数：偏移量，可正可负

- 打开a模式 fseek无效

- rewind()将流定位到文件开始位置

- 读写流时，当前读写位置自动后移

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    FILE *fp;

    if((fp=fopen("1.txt", "w")) == NULL) {
        perror("fopen");
        return 0;
    }

    fwrite("abcdef", 6, 1, fp);
    printf("current position fp=%d\n", (int)ftell(fp)); // abcd
    //fseek(fp,3,SEEK_SET);
    rewind(fp);
    printf("after rewind fp=%d\n", (int)ftell(fp));
    fwrite("jkl", 3, 1, fp); // jklabcd

    return 0;

}
```

#### 3、判断流是否出错和结束

```c
#include  <stdio.h>

int ferror(FILE *stream);
int feof(FILE *stream);
```

- ferror()返回1表示流出错；否则返回0

- feof()返回1表示文件已到末尾；否则返回0

### （六）格式化输出、输入

#### 1、格式化输出

```c
#include  <stdio.h>

int printf(const char *fmt, …);
int fprintf(FILE *stream, const char *fmt, …);
int sprintf(char *s, const char *fmt, …);
```

- 成功时返回输出的字符个数；出错时返回EOF

- 使用起来很方便

##### 1.1 fprintf

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    FILE *fp;
    int year=2024;
    int month=9;
    int day=15;

    if((fp=fopen("ftest.txt", "w")) == NULL) {
        perror("fopen");
        return 0;
    }
    fprintf(fp, "%d-%d-%d\n", year, month, day);

    fclose(fp);
    
    return 0;

}
```

##### 1.2 sprintf

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    char buf[100] = {0};
    int year=2024;
    int month=9;
    int day=15;

    int syear;
    int smonth;
    int sday;

    sprintf(buf, "%d-%d-%d", year, month, day);
    printf("%s\n", buf);

    sscanf(buf, "%d-%d-%d", &syear, &smonth, &sday);
    printf("%d %d %d\n", syear, smonth, sday);

    return 0;

}
```

#### 2、格式化输入

```c
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
```

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    FILE *fp;
    int year;
    int month;
    int day;

    if((fp=fopen("ftest.txt", "r")) == NULL) {
        perror("fopen");
        return 0;
    }

    fscanf(fp, "%d-%d-%d", &year, &month, &day);
    printf("%d %d %d\n", year, month, day);

    fclose(fp);

    return 0;

}
```

#### 3、案例

>每隔1秒向文件test.txt中写入当前系统时间，格式如下： 
>
>
>
>1,  2014-10-15 15:16:42
>
>2,  2014-10-15 15:16:43
>
>该程序无限循环，直到按Ctrl-C中断程序
>
>每次执行程序时，系统时间追加到文件末尾，序号递增
>
>
>
>1,  2014-10-15 15:16:42
>
>2,  2014-10-15 15:16:43
>
>3,  2014-10-16 11:35:07
>
>4,  2014-10-16 11:35:08
>
>
>
>time()用来获取系统时间(秒数)
>
>time_t time(time_t *seconds) 1970.1.1 0:0:0
>
>localtime()将系统时间转换成本地时间
>
>struct tm *localtime(const time_t *timer)
>
>struct tm {
>
>   int tm_sec;         /* 秒，范围从 0 到 59                */
>
>   int tm_min;         /* 分，范围从 0 到 59                */
>
>   int tm_hour;        /* 小时，范围从 0 到 23                */
>
>   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
>
>   int tm_mon;         /* 月份，范围从 0 到 11                */
>
>   int tm_year;        /* 自 1900 起的年数                */
>
>   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
>
>   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
>
>   int tm_isdst;       /* 夏令时                        */    
>
>};

```c
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>


int main(int argc, char *argv[]) {

    FILE *fp;
    time_t ctime;
    struct tm *ctimestr;
    int linecount;
    char buf[32];

    if((fp=fopen("test.txt", "a+")) == NULL) {

        perror("fopen");
        return 0;

    }

    while(fgets(buf, 32, fp) != NULL) {

        if(buf[strlen(buf)-1] == '\n') {
            linecount++;
        }

    }

    while(1) {
        ctime = time(NULL);
        ctimestr = localtime(&ctime);
        fprintf(fp, "%d, %04d-%02d-%02d %02d:%02d:%02d\n", linecount,
        ctimestr->tm_year+1900, ctimestr->tm_mon+1, ctimestr->tm_mday,
        ctimestr->tm_hour, ctimestr->tm_min, ctimestr->tm_sec);
        fflush(fp);
        linecount++;
        sleep(1);

    }

    fclose(fp);

}
```

